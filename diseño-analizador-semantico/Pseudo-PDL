Axioma = B
NoTerminales = { A B C D E F G H I J K L M N O P Q R S T U V F1 F2 F3 }
Terminales = { && == - -- ( ) = ; , { } id ent cad log let alert input return for if number boolean string function }
Producciones = {

{TS_g = CreaTS()
        TS_actual = TSG
        desp = 0
        zona_decl = true }

B -> D {}  --> ¿Para qué es esta??
D -> F D {}
D -> G D {}
D -> lambda {}


G -> if ( E ) S { if E.tipo != log
                    then error(1) }
G -> S {}
S -> H ; {}
H -> id ( I ) { if longitud(I.tipo) != busca_num_params_TS(id)
                    then error(2)
                else if busca_tipo_TS(id.pos) != I.tipo
                    then error(3)
                else
                    H.tipo = busca_tipo_devuelto_TS(id.pos) }
I -> E J { if longitud(J.tipo) == 0
                then I.tipo = E.tipo
            else
                I.tipo = E.tipo x J.tipo }
J -> , E J1 { if longitud(J1.tipo) == 0
                then J.tipo = E.tipo
              else
                J.tipo = E.tipo x J1.tipo }
J -> lambda {}
I -> lambda {  I.tipo = void }

S -> K ; {}
K -> id = E { if busca_tipo_TS(id) != E.tipo
                then error(10) }

S -> alert ( E ) ; { if E.tipo != cadena && E.tipo != entero
                        then error(4) }
S -> input ( id ) ; { if busca_tipo_TS(id) != cadena && busca_tipo_TS(id) != entero
                        then error(5) }
S -> return L ; { if zona_function != true
                    then Error(7)}
                  else if L.tipo != tipo_return --> no queremos hacer esta comprobación con una "variable global" sino con un atributo
                    then error(9) }
L -> E { L.tipo = E.tipo }
L -> lambda { L.tipo = void }


G -> let M T id ; { zona_declaración = false
                    añadir_tipo_TS(id, T.tipo)
                    añadir_desp_TS(id, desp)
                    desp += T.ancho }
M -> lambda { zona_declaracion = true }
T -> number { T.tipo = ent
              T.ancho = size_of(ent)} --> no sé si necesitáis esta función size_of, porque los tamaños son conocidos y estáticos. #A debatir
T -> boolean { T.tipo = log
               T.ancho = size_of(log)}
T -> string { T.tipo = cadena
               T.ancho = size_of(string)}


G -> for ( N ; E ; O ) { C } { if E.tipo != log
                                    then error(6) }
N -> K {}
N -> lambda {}
O -> K {}
O -> -- id { if busca_tipo_TS(id.pos) != ent
                then error(11) }  --> seguramente habrá que comprobar que este id de O sea justamente el de N #A debatir
C -> G C {}
C -> lambda {}


F -> F1 F2 F3 { añadir_param_TS(F1.id, F2.tipo, longitud(F2.tipo)) --> NO, este añadir param está demasiado tarde. Hay que hacerlo al final de F2 pero antes de F3. Y recordad
     lo que os dije de que, en el diseño, representamos el tipo de la función como hemos aprendido con el sistema de tipos: producto cartesiano de los tipos de los
     parámetros, flecha, tipo devuelto (en vuestro caso podría ser F2.tipo --> F1.tipo, si creáis bien F1.tipo). Vuestra función "longitud" en el diseño seguramente sobra y
     molesta. Tened en cuenta que "todo" se debe tratar con atributos y no con variables globales, salvo la creación de la tabla de símbolos, la variable desplazamiento y la variable
     zona_declaración. También os dejo que useis una variable global para ver si el return está dentro de la función. Y os dejo porque para hacerlo bien lo más fácil es usar
     un atributo heredado, y queremos evitar que uséis atributos heredados, así que tendriais que comprobarlo mediante la sintaxis, o usando un atributo sintetizado o con una variable
     global; y puestos a no hacer lo "mejor" (atributo heredado), os dejo cualquiera de las otras 3 opciones, así que admito la variable global. Pero diría que ni una más. Tened en
     cuenta que al no admitir el lenguaje que se declare una función dentro de otra, el tirar de variables globales funciona, pero si el lenguaje permitiera anidamiento, otro gallo
     cantaría.

                destruye_TS (TS_l)
                zona_function = false
                tipo_return = NULL}
F1 -> function P Q id {TS_l = crea_TS()
                       TS_actual = TS_l
                       desp_g = desp
                       desp = 0
                       zona_function = true
                       tipo_return = Q.tipo --> no queremos una "variable global" tipo_return
                       añadir_tipo_devuelto_TS(id, tipo_return)
                       inserta_et_TS (id.pos, nueva_et ())
                        }
P -> lambda { if zona_function == true
                then error(8) }
Q -> T { zona_declaracion = true
         Q.tipo = T.tipo }
Q -> lambda { zona_declaracion = true
              Q.tipo = void }

F2 -> ( A ) { añadir_param_TS(get_last_id(), A.tipo, longitud(A.tipo)
              TS_actual = TS_g
              desp = desp_g
              F2.tipo = A.tipo,
              zona_declaración = false }
A -> T id R { añadir_tipo_TS(id.pos, T.tipo)
              añadir_desp_TS(id, desp) --> idem
              desp += T.ancho
              if longitud(R.tipo) == 0
                then A.tipo = T.tipo
              else
                A.tipo = R.tipo x T.tipo } --> le estáis dando la vuelta a la lista de los tipos
A -> lambda { A.tipo = void }
R -> , T id R1   { añadir_tipo_TS(id, T.tipo)
                   añadir_desp_TS(id, desp)
                   desp += T.ancho
                   if longitud(R1.tipo) == 0
                    then R.tipo = T.tipo
                   else
                    R.tipo = R1.tipo x T.tipo } --> le estáis dando la vuelta a la lista de los tipos
R -> lambda {}

F3 -> { C } {}


E -> E1 && R { if E1.tipo != log || R.tipo != log
                then error(12)
               else
                E.tipo = log }
E -> R {E.tipo = R.tipo }
R -> R1 == U { if R1.tipo != ent || U.tipo != ent
                then error(13)
               else
                E.tipo = log }
R -> U { R.tipo = U.tipo }
U -> U1 - V { if U1.tipo != ent || V.tipo != ent
                then error(14)
              else
                U.tipo = ent }
U -> V { U.tipo = V.tipo }
V -> -- id { if busca_tipo_TS(id) != ent
                then error(15)
             else
                V.tipo = ent }
V -> id { V.tipo = busca_tipo_TS(id) }
V -> ( E ) { V.tipo = E.tipo }
V -> H { V.tipo = H.tipo}
V -> ent { V.tipo = ent }
V -> cad { V.tipo = cad }
V -> log { V.tipo = log }

# error_code_to_string(error_code, *args): #A revisar cuando se vaya a implementar la función
    error_code_dict = {
        1: "La condición debe ser un lógico",
        2: "El número de parámetros introducidos no son los esperados, deberían ser {busca_num_params_TS(id)}",
        3: "El tipo de los parámetros no es el esperado, se esperaban {busca_tipo_params_TS(id)}",
        4: "La expresión introducida no es una cadena o un entero",
        5: "La variable introducida no es de tipo cadena o entero",
        6: "La condición debe ser un lógico",
        7: "No puede haber return fuera de una función",
        8: "No se permite la definición de funciones anidadas",
        9: "El tipo de retorno no corresponde con el tipo de retorno de la función, se esperaba {tipo_return}",
        10: "El tipo de la variable a asignar no corresponde con el tipo asignado",
        11: "El operador especial '--' solo trabaja con tipos de datos enteros",
        12: "El operador lógico '&&' solo trabaja con tipos de datos lógicos"
        13: "El operador de relación '==' solo trabaja con tipos de datos enteros"
        14: "El operador aritmético '-' solo trabaja con tipos de datos enteros"
        15: "El operador especial '--' solo trabaja con tipos de datos enteros"
    }

function error(error_code):
    res = ""
    if error_code <= 6:
       res = "ErrorDeAtributo: "
    elif error_code >= 9:
       res = "ErrorDeTipado: "
    else
       res = "NoImplementado: "
    res = res + error_code_dict.get(error_code, default="Código no válido")
    print(res)





