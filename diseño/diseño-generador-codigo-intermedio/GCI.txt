Y -> P1 {
    Y.cod = P1.cod
    }
P -> B P1 {
    P.cod = B.cod || P1.cod
    }
P -> F P1 {
    P.cod = F.cod || P1.cod
    }
P -> lambda {
    P.cod = vacio
    }
B -> si (E) S {
    S.sig = nuevaetiq ()
    E.verdad = nuevaetiq ()
    E.falso = S.sig
    B.cod = E.cod || gen (:, E.verdad) || S.cod || gen (goto, S.sig) || gen (:, S.sig)
    }
B -> sea T id; {
    B.cod = vacio
    }
B -> S {
    B.cod = S.cod
    }
B -> para (D; E; Z) {C} {
    B.inicio = nuevaetiq ()
    E.verdad = nuevaetiq ()
    E.falso = nuevaetiq ()
    B.cod = D.cod || gen (:, B.inicio) || E.cod || gen (:, E.verdad) || C.cod || Z.cod || gen (goto, B.inicio) || gen (:, E.falso)
    }
S -> id = E; {
    S.cod = E.cod || gen (BLTS (id.pos), =, E.lugar)
    }
S -> id (L); {
    S.cod = L.codE || L.codP || gen (llamada, APUESTAS (id.pos))
    }
S -> alerta (E);
S -> entrada (id);
S -> devuelve X; {
    si (X.cod = vacio)
        S.cod = gen (retorno)
    demás
        S.cod = gen (retorno, X.lugar)
    }
T -> número {
    T.lugar = nuevotemp ()
    T.cod = gen (T.lugar, =, número.valor)
    }
T -> booleano {
    T.lugar = nuevotemp ()
    T.cod = gen (T.lugar, =, valor booleano)
    }
T -> cadena {
    T.lugar = nuevotemp ()
    T.cod = gen (T.lugar, =, string.value)
    }
F -> F1 F2 F3 {
    F.cod = F1.cod || F2.cod || F3.cod || gen (regreso)
    }
F1 -> función H id {
    F1.cod = gen (:, APUESTAS (id.pos))
    }
F2 -> (A) {
    F2.cod = vacio
    }
F3 -> {C} {
    F3.cod = C.cod
    }
E -> E1 && R {
    E1.verdad = nuevaetiq ()
    E1.falso = E.falso
    R.verdad = E.verdad
    R.falso = E.falso
    E.cod = E1.cod || gen (:, E1.verdad) || R.cod
    }
E -> R {
    E.cod = R.cod
    }
R -> R1 == U {
    R.cod = gen (si, R1.lugar, =, U.lugar, goto, R.verdad) || gen (ir, R.falso)
    }
R -> U {
    R.cod = U.cod
    R.lugar = U.lugar
    }
U -> U1 - V {
    U.lugar = nuevotemp ()
    U.cod = gen (U.lugar, =, U1.lugar, -, V.lugar)
    }
U -> V {
    U.cod = V.cod
    U.lugar = V.lugar
    }
V -> - id {
    V.lugar = nuevotemp ()
    id.lugar = BLTS (id.pos)
    V.cod = gen (id.lugar, =, id.lugar, -, 1) || gen (V.lugar, =, id.lugar)
    }
V -> id {
    V.lugar = nuevotemp ()
    V.cod = gen (V.lugar, =, BLTS (id.pos)
    }
V -> (E) {
    V.cod = E.cod
    }
V -> id (L) {
    }
V -> ent {
    V.lugar = nuevotemp ()
    gen (V.lugar, =, ent.valor)
    }
V -> cad {
    V.lugar = nuevotemp ()
    gen (V.lugar, =, cad.valor)
    }
V -> log {
    V.cod = gen (si, log.valor, =, 1, goto, V.verdad) || gen (goto, V.falso)
    }
X -> E {
    X.cod = E.cod
    X.lugar = E.lugar
    }
X -> lambda {
    X.cod = vacio
    }
L -> EQ {
    L.codE = E.cod || Q.codE

L -> lambda
Q ->, EQ
Q -> lambda
D -> id = E
D -> lambda
Z -> id = E
Z -> - id
Z -> lambda
H -> T
H -> lambda
A -> T id K
A -> lambda
K ->, T id K
K -> lambda
C -> BC
C -> lambda
}